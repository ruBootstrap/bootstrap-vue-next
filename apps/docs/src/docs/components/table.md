# Таблицы

<PageHeader>

Для отображения табличных данных, `BTable` поддерживает пагинацию, фильтрацию, сортировку, пользовательское форматирование, различные стилевые опции, события и асинхронные данные. Для простого отображения табличных данных без всех этих функций, BootstrapVueNext предоставляет два легковесных альтернативных компонента [`BTableLite`](#light-weight-tables) и [`BTableSimple`](#simple-tables).

</PageHeader>

## Основное использование

<<< DEMO ./demo/TableOverview.vue

## Элементы (данные записи)

`items` — это данные таблицы в формате массива, где каждая запись (строка) представляет собой объект с ключами. Пример формата:

<<< FRAGMENT ./demo/TableItems.ts#snippet{ts}

`<BTable>` автоматически выбирает первую строку для извлечения имен полей (ключи в данных записи). Имена полей автоматически "человекообразуются" путем преобразования `kebab-case`, `snake_case`, и `camelCase` в отдельные слова и каждое слово заглавляется. Примеры преобразований:

- `first_name` становится `First Name`
- `last-name` становится `Last Name`
- `age` становится `Age`
- `YEAR` остается `YEAR`
- `isActive` становится `Is Active`

Эти заголовки будут отображаться в заголовке таблицы, в том порядке, в котором они появляются в **первой** записи данных. См. раздел [Поля (определения столбцов)](#fields-column-definitions) ниже для настройки того, как заголовки полей отображаются.

::: info ПРИМЕЧАНИЕ
Порядок полей не гарантируется. Поля обычно появляются в том порядке, в котором они были определены в первой строке, но это может не всегда быть так, в зависимости от версии браузера в использовании. См. раздел [Поля (определения столбцов)](#fields-column-definitions) ниже, чтобы увидеть, как обеспечить порядок полей, и переопределить сгенерированные заголовки.
:::

Данные записи могут также иметь дополнительные специальные зарезервированные имена ключей для окрашивания строк и отдельных ячеек (варианты), а также для активации дополнительной информации о строке. Тип [TableItem](/docs/types#tableitem) определяет поддерживаемые опциональные свойства модификатора записи записи (убедитесь, что ваши ключи полей не конфликтуют с этими именами):

| Свойство        | Тип                                    | Описание                                                                                                                                                                                                                                                                                    |
| --------------- | -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `_cellVariants` | Partial<Record<keyof T, ColorVariant>> | Контекстные состояния Bootstrap, применяемые к отдельным ячейкам. Ключами являются поля (см. [Варианты цветов](/docs/reference/color-variants) для поддерживаемых значений). Эти варианты сопоставляются с классами `table-${variant}` или `bg-${variant}` (когда установлен пропс `dark`). |
| `_rowVariant`   | ColorVariant                           | Контекстные состояния Bootstrap, применяемые к целой строке (см. [Варианты цветов](/docs/reference/color-variants) для поддерживаемых значений). Эти варианты сопоставляются с классами `table-${variant}` или `bg-${variant}` (когда установлен пропс `dark`).                             |
| `_showDetails`  | boolean                                | Используется для активации отображения слота `row-details` scoped. См. раздел [Поддержка деталей строк](#row-details-support) ниже для дополнительной информации                                                                                                                            |

### Пример: использование вариантов для табличных ячеек

<<< DEMO ./demo/TableCellVariants.vue

Вместо установки `items` можно предоставить функцию поставщика, которая возвращает элементы синхронно или асинхронно. См. раздел ["Использование функций поставщика элементов"](#using-items-provider-functions) ниже для получения дополнительной информации.

### Заметки и предупреждения по элементам таблицы

- Избегайте изменения данных записи на месте, так как изменения подлежащих данных `items` приведут к перерендерингу как строки, так и всей таблицы. См. раздел [Основной ключ](#primary-key), ниже, для способов минимизации перерендеринга строк Vue.
- Записи массива `items` должны быть простыми объектами и **должны** избегать размещения данных, которые могут иметь циклические ссылки в значениях внутри строки. `<BTable>` сериализует данные строки в строки для сортировки и фильтрации, и циклические ссылки приведут к переполнению стека и крэш вашего приложения!

## Поля (определения столбцов)

Пропс `fields` используется для настройки заголовков столбцов таблицы и порядка отображения столбцов данных. Ключи объекта полей (например, `age` или `first_name`, как показано ниже) используются для извлечения значения из каждой записи (строки) элемента, а также для предоставления дополнительных функций, таких как включение [сортировки](#sorting) на столбец и т.д.

Поля могут быть предоставлены как _простой массив_ или _массив объектов_. **Внутренние данные полей будут нормализованы в формат _массива объектов_**. События или слоты, включающие данные столбца `field`, будут находиться в нормализованном формате объекта поля (массив объектов для `fields`, или объект для отдельного `field`).

### Поля как простой массив

Поля могут быть простым массивом, для определения порядка столбцов и отображения столбцов:

<<< DEMO ./demo/TableFieldArray.vue

### Поля как массив объектов

Поля могут быть массивом объектов, предоставляющим дополнительный контроль над полями (например, сортировку, форматирование и т.д.). Показываются только столбцы (ключи), которые появляются в массиве полей:

<<< DEMO ./demo/TableFieldObjects.vue

### Справочник по определению поля

Следующие свойства поля (определенные как [TableField](/docs/types#tableitem)) распознаются:

| Свойство            | Тип                                                                                                | Описание                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ------------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `key`               | `LiteralUnion<keyof T>`                                                                            | Ключ для выбора данных из массива `items`. Требуется, когда `fields` устанавливается через массив объектов. Ключ также используется для генерации [пользовательского форматирования данных](#custom-data-rendering) и имен слотов для [пользовательского рендеринга заголовка и футера](#header-and-footer-custom-rendering-via-scoped-slots)                                                                              |
| `label`             | `string`                                                                                           | Отображается в заголовке таблицы (и футере, если установлен `foot-clone`). По умолчанию — ключ поля (в человекообразуемом формате) если не указан. Возможно использование пустых меток, назначив пустую строку `""`, но убедитесь, что также установлен `headerTitle` для предоставления подсказки для пользователей с ограниченными возможностями о содержании столбца.                                                   |
| `headerTitle`       | `string`                                                                                           | Текст для размещения в заголовке полей `<th>` атрибут `title`. По умолчанию — отсутствует атрибут `title`.                                                                                                                                                                                                                                                                                                                 |
| `headerAbbr`        | `string`                                                                                           | Текст для размещения в заголовке полей `<th>` атрибут `abbr`. Установите этот атрибут на несокращенную версию метки (или заголовка) если метка (или заголовок) является аббревиатурой. По умолчанию — отсутствует атрибут `abbr`.                                                                                                                                                                                          |
| `class`             | `ClassValue`                                                                                       | Имя класса (или массив имен классов) для добавления в `<th>` **и** `<td>` в столбце.                                                                                                                                                                                                                                                                                                                                       |
| `formatter`         | `TableFieldFormatter<T>`                                                                           | Вместо (или в сочетании с) скрытых слотов поля можно использовать функцию форматирования. Функция форматирования будет вызываться с синтаксисом `formatter<T>(value: unknown, key: string, item: T)`. См. раздел [Пользовательское форматирование данных](#custom-data-rendering) для получения дополнительной информации.                                                                                                 |
| `sortable`          | `boolean`                                                                                          | Включите сортировку для этого столбца. См. раздел [Сортировка](#sorting) для получения дополнительной информации.                                                                                                                                                                                                                                                                                                          |
| `sortDirection`     | `string`                                                                                           | Установите начальное направление сортировки для этого столбца, когда оно становится отсортированным. См. раздел [Изменение начального направления сортировки](#change-initial-sort-direction) для получения дополнительной информации.<NotYetImplemented/>                                                                                                                                                                 |
| `sortByFormatted`   | `boolean \| TableFieldFormatter<T>`                                                                | Сортируйте столбец по результату функции форматирования поля, когда установлено значение `true`. По умолчанию — `false`. Булево значение не имеет значения, если поле не имеет функции форматирования. Опционально принимает функцию форматирования _ссылку_ для форматирования значения только для сортировки. См. раздел [Сортировка](#sorting) для получения дополнительной информации.                                 |
| `filterByFormatted` | `boolean \| TableFieldFormatter<T>`                                                                | Фильтруйте столбец по результату функции форматирования поля, когда установлено значение `true`. По умолчанию — `false`. Булево значение не имеет значения, если поле не имеет функции форматирования. Опционально принимает функцию форматирования _ссылку_, которая будет использоваться для форматирования значения только для фильтрации. См. раздел [Фильтрация](#filtering) для получения дополнительной информации. |
| `tdClass`           | `TableStrictClassValue \| ((value: unknown, key: string, item: T) => TableStrictClassValue)`       | Имя класса (или массив имен классов) для добавления в `<tbody>` данные `<td>` ячейки в столбце. Если требуются пользовательские классы для каждой ячейки, можно указать функцию обратного вызова вместо. См. определение TypeScript для принятых параметров и возвращаемых типов.                                                                                                                                          |
| `thClass`           | `ClassValue`                                                                                       | Имя класса (или массив имен классов) для добавления в `<thead>`/`<tfoot>` заголовок `<th>` ячейку.                                                                                                                                                                                                                                                                                                                         |
| `thStyle`           | `StyleValue`                                                                                       | CSS стили, которые вы хотите применить к `<thead>`/`<tfoot>` ячейке `<th>` поля.                                                                                                                                                                                                                                                                                                                                           |
| `variant`           | `ColorVariant \| null`                                                                             | Примените контекстный класс ко всем `<th>` **и** `<td>` в столбце.                                                                                                                                                                                                                                                                                                                                                         |
| `tdAttr`            | `AttrsValue \| ((value: unknown, key: string, item: T) => AttrsValue)`                             | Объект, представляющий дополнительные атрибуты для применения к `<tbody>` ячейке `<td>` поля. Если требуются пользовательские атрибуты для каждой ячейки, можно указать функцию обратного вызова вместо. См. определение TypeScript для принятых параметров и возвращаемых типов.                                                                                                                                          |
| `thAttr`            | `AttrsValue \| ((value: unknown, key: string, item: T \| null, type: TableRowThead) => AttrsValue` | Объект, представляющий дополнительные атрибуты для применения к `<thead>`/`<tfoot>` заголовку `<th>` ячейке. Если `isRowHeader` поля установлен в `true`, атрибуты также будут применяться к `<tbody>` ячейке `<th>`. Если требуются пользовательские атрибуты для каждой ячейки, можно указать функцию обратного вызова вместо. См. определение TypeScript для принятых параметров и возвращаемых типов.                  |
| `isRowHeader`       | `boolean`                                                                                          | Когда установлено в `true`, ячейка данных элемента будет отрендерена с `<th>` вместо значения по умолчанию `<td>`.                                                                                                                                                                                                                                                                                                         |
| `stickyColumn`      | `boolean`                                                                                          | Когда установлено в `true`, и таблица в режиме [отзывчивости](#responsive-tables) или имеет [фиксированные заголовки](#sticky-headers), столбец станет фиксированным слева при прокрутке горизонтальной полосы прокрутки таблицы. См. раздел [Фиксированные столбцы](#sticky-columns) для получения дополнительной информации                                                                                              |
| `scope`             | `TableThScope`                                                                                     | Атрибут `scope` для элемента `<th>` в таблице. Это используется для указания отношения ячейки заголовка к ячейкам данных. Допустимые значения: `row`, `col`, `rowgroup`, и `colgroup`. По умолчанию — `colgroup`, если указан `colspan`, `rowgroup`, если указан `rowspan`, иначе — `col`.                                                                                                                                 |

**Примечания:**

- Свойства поля, если не указаны, по умолчанию равны `null` (ложные), если не указано иначе.
- `class`, `thClass`, `tdClass` и т.д. не будут работать с классами, определенными в скрытых CSS,
  если вы используете
  [Глубокий селектор](https://vuejs.org/api/sfc-css-features.html#deep-selectors) Vue.
- Для информации о поддерживаемом синтаксисе `thStyle`, см.
  [Классы и стили привязки](https://vuejs.org/guide/essentials/class-and-style.html#Binding-Inline-Styles)
  в руководстве Vue.js.
- Любые дополнительные свойства, добавленные к объектам определений полей, останутся неизменными — поэтому вы можете получить доступ к ним через именованные скрытые слоты для пользовательского рендеринга данных, заголовка и футера.

Для информации и использования о скрытых слотах и функциях форматирования см. раздел
[Пользовательское форматирование данных](#custom-data-rendering) ниже.

Свободно смешивайте простой массив и массив объектов:

<<< FRAGMENT ./demo/TableFields.ts#snippet{ts}

## Основной ключ

`<BTable>` предоставляет дополнительный пропс `primary-key`, который вы можете использовать для идентификации _имени_ ключа поля, которое _уникально_ идентифицирует строку.

Значение, указанное ключом столбца основного ключа **должно быть** либо `string`, либо `number`, и **должно быть уникальным** во всех строках таблицы.

Столбец основного ключа не должен появляться в отображаемых полях.

### Генерация ID строки таблицы

Когда предоставлено, `primary-key` сгенерирует уникальный ID для каждой строки элемента `<tr>`. ID будет в формате `{table-id}__row_{primary-key-value}`, где `{table-id}` — это уникальный ID `<BTable>`, а `{primary-key-value}` — это значение поля записи для поля, указанного `primary-key`.

### Оптимизация рендеринга и переход таблицы

`primary-key` также используется `<BTable>` для помощи Vue в оптимизации рендеринга строк таблицы. Внутренне, значение ключа поля, указанного пропсом `primary-key`, используется в качестве значения `:key` для каждой отрендеренной строки элемента `<tr>`.

Если вы видите проблему с рендерингом (например, подсказки скрываются или неожиданное повторное использование подкомпонентов при изменении данных или данных сортируются/фильтруются/редактируются) или переходы строк таблицы не работают, установка пропса `primary-key` (если у вас есть уникальный идентификатор для каждой строки) может уменьшить эти проблемы.

Указание столбца основного ключа удобно, если вы используете 3-й сторонние переходы таблиц или плагины перетаскивания, так как они зависят от наличия постоянного и уникального значения `:key` для каждой строки.

Если `primary-key` не предоставлен, `<BTable>` автоматически генерирует ключи на основе индекса отображаемой строки (т.е. номер в _отображаемых_ строках таблицы). Это может вызвать GUI-проблемы, такие как подкомпоненты/элементы, которые рендерятся с предыдущими результатами (т.е. переиспользуются оптимизацией рендеринга Vue). Указание столбца основного ключа может уменьшить эту проблему (или вы можете разместить уникальный `:key` на ваших элементах/компонентах в ваших скрытых слотах форматирования поля).

См. раздел [Поддержка перехода тела таблицы](#table-body-transition-support) для дополнительной информации.

## Стиль таблицы

### Стилизация таблицы

`<BTable>` предоставляет несколько пропсов для изменения стиля таблицы:

| пропс                | Тип                   | Описание                                                                                                                                                                                                                                                                                                                                                                                                               |
| -------------------- | --------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `striped`            | boolean               | Добавьте полоски в строки таблицы в `<tbody>`                                                                                                                                                                                                                                                                                                                                                                          |
| `striped-columns`    | boolean               | Добавьте полоски в столбцы таблицы в `<tbody>`                                                                                                                                                                                                                                                                                                                                                                         |
| `bordered`           | boolean               | Для границ со всех сторон таблицы и ячеек.                                                                                                                                                                                                                                                                                                                                                                             |
| `borderless`         | boolean               | Удаляет внутренние границы из таблицы.                                                                                                                                                                                                                                                                                                                                                                                 |
| `outlined`           | boolean               | Для тонкой границы со всех сторон таблицы. Не имеет эффекта, если установлен `bordered`.                                                                                                                                                                                                                                                                                                                               |
| `small`              | boolean               | Чтобы сделать таблицы более компактными, уменьшив поля ячеек вдвое.                                                                                                                                                                                                                                                                                                                                                    |
| `hover`              | boolean               | Чтобы включить состояние подсветки при наведении на строки таблицы в `<tbody>`                                                                                                                                                                                                                                                                                                                                         |
| `dark`               | boolean               | Инвертируйте цвета — с светлым текстом на темных фоновых цветах (эквивалент Bootstrap v5 классу `.table-dark`)                                                                                                                                                                                                                                                                                                         |
| `fixed`              | boolean               | Создайте таблицу с равными фиксированными столбцами ширины (`table-layout: fixed;`) <NotYetImplemented/>                                                                                                                                                                                                                                                                                                               |
| `responsive`         | boolean \| Breakpoint | Создайте отзывчивую таблицу для горизонтальной прокрутки. Установите `true` для всегда отзывчивой таблицы, или установите его в одно из значений [точек останова](/docs/types#breakpoint) `'sm'`, `'md'`, `'lg'`, `'xl'` или `'xxl'`, чтобы сделать таблицу отзывчивой (горизонтально прокручивающейся) только на экранах меньше точки останова. См. раздел [Отзывчивые таблицы](#responsive-tables) ниже для деталей. |
| `sticky-header`      | boolean \| Numberish  | Создает вертикально прокручиваемую таблицу с фиксированными заголовками. Установите `true`, чтобы включить фиксированные заголовки (максимальная высота таблицы по умолчанию `300px`), или установите его в строку, содержащую высоту (с единицами CSS), чтобы указать другую максимальную высоту, отличную от `300px`. См. раздел [Фиксированные заголовки](#sticky-headers) ниже для деталей.                        |
| `stacked`            | boolean \| Breakpoint | Создайте отзывчивую визуально наложенную таблицу. Установите `true` для всегда наложенной таблицы, или установите его в одно из значений [точек останова](/docs/types#breakpoint) `'sm'`, `'md'`, `'lg'`, `'xl'` или `'xxl'`, чтобы сделать таблицу визуально наложенной только на экранах меньше точки останова. См. раздел [Наложенные таблицы](#stacked-tables) ниже для деталей.                                   |
| `caption-top`        | boolean \| Numberish  | Если таблица имеет подпись, и этот пропс установлен в `true`, подпись будет визуально размещена над таблицей. Если `false` (по умолчанию), подпись будет визуально размещена под таблицей.                                                                                                                                                                                                                             |
| `variant`            | ColorVariant \| null  | Укажите цветовой вариант для всей таблицы.                                                                                                                                                                                                                                                                                                                                                                             |
| `head-variant`       | ColorVariant \| null  | Сделайте заголовок таблицы цветом темы, отличным от таблицы.                                                                                                                                                                                                                                                                                                                                                           |
| `foot-row-variant`   | ColorVariant \| null  | Сделайте футер таблицы цветом темы, отличным от таблицы. Если не установлено, `head-variant` будет использоваться. Не имеет эффекта, если `foot-clone` не установлен                                                                                                                                                                                                                                                   |
| `head-row-variant`   | ColorVariant \| null  | Сделайте только `<tr>` часть `<head>` цветом определенной темы.                                                                                                                                                                                                                                                                                                                                                        |
| `foot-variant`       | ColorVariant \| null  | Сделайте только `<tr>` часть `<foot>` цветом определенной темы. Если не установлено, `head-row-variant` будет использоваться. Не имеет эффекта, если `foot-clone` не установлен                                                                                                                                                                                                                                        |
| `foot-clone`         | boolean               | Включает футер таблицы, и по умолчанию содержит то же содержимое, что и заголовок таблицы.                                                                                                                                                                                                                                                                                                                             |
| `no-footer-sorting`  | boolean               | Когда `foot-clone` установлен в `true` и таблица сортируема, отключает значки сортировки и поведение при нажатии на ячейки заголовка футера. См. раздел [Сортировка](#sorting) ниже для получения дополнительной информации. <NotYetImplemented/>                                                                                                                                                                      |
| `no-border-collapse` | Boolean               | Отключает дефолтную схлопывающуюся границу таблицы. В основном для использования с [фиксированными заголовками](#sticky-headers) и/или [фиксированными столбцами](#sticky-columns). Это может вызвать появление двойных границ в некоторых ситуациях. <NotYetImplemented/>                                                                                                                                             |

::: info ПРИМЕЧАНИЕ
Опции стиля таблицы `fixed`, `stacked`, `no-border-collapse`, фиксированные заголовки, фиксированные столбцы и функция сортировки таблицы требуют пользовательского CSS BootstrapVueNext.
:::

<<< DEMO ./demo/TableBasicStyles.vue

### Стилизация строк и атрибуты

Вы также можете стилизовать каждую строку, используя пропс `tbody-tr-class`, и опционально предоставьте дополнительные атрибуты через пропс `tbody-tr-attr`:

| Свойство         | Тип                                                                                             | Описание                                            |
| ---------------- | ----------------------------------------------------------------------------------------------- | --------------------------------------------------- |
| `tbody-tr-class` | `((item: Items \| null, type: TableRowType) => TableStrictClassValue) \| TableStrictClassValue` | Классы для применения ко всем строкам на таблице.   |
| `tbody-tr-attr`  | `((item: Items \| null, type: TableRowType) => AttrsValue) \| AttrsValue`                       | Атрибуты для применения ко всем строкам на таблице. |

При передаче ссылки на функцию `tbody-tr-class` или `tbody-tr-attr` аргументы функции будут следующими:

- `item` — Запись данных элемента, связанная с строкой. Для строк, не связанных с записью данных элемента, это значение будет `null` или `undefined`
- `type` — Тип отрендеренной строки ([TableRowType](/docs/types#tablefield)). `'row'` для строки элемента, `'row-details'` для строки деталей элемента, `'row-top'` для фиксированной верхней строки слота, `'row-bottom'` для фиксированной нижней строки слота, или `'table-busy'` для слота занятой таблицы.

<<< DEMO ./demo/TableRowStyles.vue

### Отзывчивые таблицы

Отзывчивые таблицы позволяют легко горизонтально прокручивать таблицы. Сделайте любую таблицу отзывчивой по всем видам экранов, установив пропс `responsive` в `true`. Или, выберите максимальную точку останова, до которой таблица будет отзывчивой, установив пропс `responsive` в одно из значений точек останова: `sm`, `md`, `lg`, или `xl`.

<<< DEMO ./demo/TableResponsive.vue

**Примечания по отзывчивым таблицам:**

- _Возможное вертикальное обрезание/усечение_. Отзывчивые таблицы используют `overflow-y: hidden`, который обрезает любое содержимое, выходящее за нижние или верхние края таблицы. В частности, это может обрезать выпадающие меню и другие виджеты третьих сторон.
- Использование пропсов `responsive` и `fixed` вместе не будет работать так, как ожидается. Фиксированный макет таблицы использует первую строку (заголовок таблицы в этом случае) для вычисления необходимой ширины каждого столбца (и общей ширины таблицы) для подгонки к ширине родительского контейнера &mdash; без учета ячеек в `<tbody>` &mdash; что приводит к таблице, которая может не быть отзывчивой. Чтобы обойти это ограничение, вам нужно указать ширины для столбцов (или определенных столбцов) одним из следующих методов:
  - Используйте элементы `<col>` в скрытом слоте [`table-colgroup`](#table-colgroup), которые имеют установленные ширины (например, `<col style="width: 20rem">`), или
  - Оберните ячейки заголовка в элементы `<div>`, через использование
    [пользовательского рендеринга заголовка](#header-and-footer-custom-rendering-via-scoped-slots), которые имеют установленную минимальную ширину, или
  - Используйте свойство `thStyle` объекта [определения поля](#field-definition-reference), чтобы установить ширину для столбца(ов), или
  - Используйте пользовательский CSS для определения классов, которые будут применяться к столбцам для установки ширин, через свойства `thClass` или `class` объекта [определения поля](#field-definition-reference).

### Наложенные таблицы

Альтернатива отзывчивым таблицам, BootstrapVue включает опцию наложенной таблицы (с использованием пользовательского SCSS/CSS), которая позволяет отрендерить таблицу в визуально наложенном формате. Сделайте любую таблицу наложенной по всем видам экранов, установив пропс `stacked` в `true`. Или, альтернативно, установите точку останова, при которой таблица вернется к обычному формату таблицы, установив пропс `stacked` в одно из значений точек останова `'sm'`, `'md'`, `'lg'`, или `'xl'`.

Метки заголовков столбцов будут отрендерены слева от каждого значения поля с помощью псевдоэлемента CSS `::before`, с шириной 40%.

Пропс `stacked` имеет приоритет над пропсом [`sticky-header`](#sticky-headers) и свойством `stickyColumn` определения поля.

<<< DEMO ./demo/TableStacked.vue

**Примечание: Когда таблица визуально наложена:**

- Заголовок таблицы (и футер таблицы) будет скрыт.
- Скрытые слоты пользовательского рендеринга заголовка не будут показаны, вместо этого будут использоваться метки полей.
- Таблица **не может** быть отсортирована по щелчку отрендеренных меток полей. Вам потребуется предоставить внешний контроль для выбора поля для сортировки и направления сортировки. См. раздел [Сортировка](#sorting) ниже для информации о контроле сортировки, а также пример полного примера внизу этой страницы для примера управления сортировкой с использованием форм-контролов.
- Слоты `top-row` и `bottom-row` будут скрыты при визуально наложенном режиме.
- Подпись таблицы, если она предоставлена, всегда будет отображаться вверху таблицы при визуально наложенном режиме.
- В всегда наложенной таблице заголовок и футер, а также фиксированные верхнюю и нижнюю строки слоты не будут отрендерены.

BootstrapVueNext требует пользовательского CSS для поддержки наложенных таблиц.

### Подпись таблицы

Добавьте необязательную подпись к своей таблице через пропс `caption` или именованный слот `table-caption` (слот имеет приоритет над пропсом). По умолчанию стилизация Bootstrap v4 размещает подпись внизу таблицы:

<<< DEMO ./demo/TableCaption.vue

Вы можете разместить подпись вверху таблицы, установив пропс `caption-top` в `true`:

<<< DEMO ./demo/TableCaptionTop.vue

Вы также можете использовать [пользовательский CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/caption-side) для контроля размещения подписи.

### Столбцы таблицы

Слот `table-colgroup` позволяет включить элемент `<colgroup>` в вашу таблицу. Вы можете использовать этот слот для указания ширин для столбцов с помощью элемента `<col>`.

<<< DEMO ./demo/TableColgroup.vue

### Состояние занятости таблицы

`<BTable>` предоставляет модель `busy`, которая пометит таблицу как занятая, которую вы можете установить в `true` прямо перед обновлением элементов, а затем установить в `false`, когда у вас будут элементы. Когда в состоянии занятости, таблица будет иметь атрибут `aria-busy="true"`.

В состоянии занятости таблица будет отрендерена в "заглушенном" виде (`opacity: 0.55`), используя следующий пользовательский CSS:

<<< FRAGMENT ./demo/TableBusy.css#snippet{css}

#### Слот table-busy

<<< DEMO ./demo/TableBusy.vue

Также см. раздел [Использование функций поставщика элементов](#using-items-provider-functions) ниже для дополнительной информации о состоянии `busy`.

**Примечания:**

- Все события, связанные с щелчком, и события изменения сортировки не будут вызываться, когда таблица находится в состоянии `busy`.
- Стилизация и слот занятости недоступны в компоненте `<BTableLite>`.

## Пользовательское форматирование данных

Для каждого поля данных в строке возможно пользовательское форматирование с использованием либо
[скрытых слотов](https://vuejs.org/guide/components/slots.html#scoped-slots), либо функции обратного вызова форматирования, либо их комбинации.

### Скрытые слоты поля

Скрытые слоты поля дают вам больший контроль над тем, как выглядят записи данных. Вы можете использовать скрытые слоты для предоставления пользовательского рендеринга для определенного поля. Если вы хотите добавить дополнительное поле, которого нет в записях, просто добавьте его в массив [`fields`](#fields-column-definitions), а затем ссылайтесь на поле(а) в скрытых слотах. Скрытые слоты поля используют следующий синтаксис именования: `` `'cell(${field_key})'` ``.

Вы можете использовать _fallback_ скрытый слот по умолчанию `'cell()'` для форматирования любых ячеек, которые не имеют явного скрытого слота.

<<< DEMO ./demo/TableCustomData.vue

Свойства области действия слота (`data` в примере выше) будут иметь следующие свойства:

| Свойство         | Тип                                | Описание                                                                                                                                                                         |
| ---------------- | ---------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `index`          | number                             | Номер строки (отсчитываемый от нуля) относительно _отображаемых_ строк                                                                                                           |
| `item`           | Items                              | Полные необработанные данные записи (т.е. `items[index]`) для этой строки (перед применением функции форматирования)                                                             |
| `value`          | unknown                            | Значение для этого ключа в записи (`null` или `undefined`, если виртуальный столбец), или результат функции форматирования поля (`formatter`)                                    |
| `unformatted`    | unknown                            | Необработанное значение для этого ключа в записи данных элемента (`null` или `undefined`, если виртуальный столбец), перед передачей в функцию форматирования поля (`formatter`) |
| `field`          | `(typeof computedFields.value)[0]` | Нормализованный объект определения поля поля                                                                                                                                     |
| `detailsShowing` | boolean                            | Будет `true`, если видимый скрытый слот `row-details` видим. См. раздел [Поддержка деталей строк](#row-details-support) ниже для дополнительной информации                       |
| `toggleDetails`  | `() => void`                       | Можно вызвать для переключения видимости скрытого слота `row-details`. См. раздел [Поддержка деталей строк](#row-details-support) ниже для дополнительной информации             |
| `rowSelected`    | boolean                            | Будет `true`, если строка выбрана. См. раздел [Поддержка выбора строк](#row-select-support) для дополнительной информации                                                        |
| `selectRow`      | `(index?: number) => void`         | Когда вызывается, выбирает текущую строку. См. раздел [Поддержка выбора строк](#row-select-support) для дополнительной информации                                                |
| `unselectRow`    | `(index?: number) => void`         | Когда вызывается, отменяет выбор текущей строки. См. раздел [Поддержка выбора строк](#row-select-support) для дополнительной информации                                          |

**Примечания:**

- `index` не всегда будет фактическим номером строки, так как он вычисляется после фильтрации, сортировки и пагинации по исходным данным таблицы. Значение `index` будет относиться к **номеру отображаемой строки**.
- При использовании синтаксиса `v-slot`, обратите внимание, что имена слотов **не могут** содержать пробелы, и когда используются в браузерных шаблонах DOM, имена слотов будут _всегда_ в нижнем регистре. Чтобы обойти это, вы можете передать имя слота, используя динамические имена слотов Vue

#### Отображение сырых HTML

По умолчанию `BTable` экранирует HTML-теги в данных элементов и результатах функций форматирования, если вам нужно отобразить сырый HTML-код в `BTable`, вы должны использовать директиву `v-html` на элементе в скрытом слоте поля.

<<< DEMO ./demo/TableRawHtml.vue

::: danger ВНИМАНИЕ
Будьте осторожны при использовании метода <code>v-html</code> для отображения пользовательских
контентов, так как он может сделать ваше приложение уязвимым для
<a class="alert-link" href="https://en.wikipedia.org/wiki/Cross-site_scripting">
<abbr title="Атаки межсайтового скриптинга">XSS-атак</abbr></a>, если вы не сначала
<a class="alert-link" href="https://en.wikipedia.org/wiki/HTML_sanitization">очистите</a>
пользовательскую строку.
:::

### Функция обратного вызова форматирования

Необязательно, вы можете настроить вывод поля, используя функцию обратного вызова форматирования. Для этого используется свойство `formatter` поля. Значение этого свойства может быть строкой или ссылкой на функцию. В случае строкового значения функция должна быть определена в методах родительского компонента. При предоставлении `formatter` как `Function`, она должна быть объявлена в глобальной области видимости (окно или как глобальная миксин в Vue, или как анонимная функция), если она не была привязана к контексту `this`.

Функция обратного вызова принимает три аргумента - `value`, `key`, и `item`, и должна возвращать отформатированное значение в виде строки (HTML-строки не поддерживаются)

<<< DEMO ./demo/TableFormatter.vue

## Пользовательское рендеринг заголовка и футера через скрытые слоты

Также возможно предоставить пользовательское рендеринг для элементов `thead` и `tfoot` таблицы. По умолчанию футер таблицы не отрендерен, если `foot-clone` установлен в `true`.

Скрытые слоты для ячеек заголовка и футера используют специальный синтаксис именования `'head(<fieldkey>)'` и `'foot(<fieldkey>)'` соответственно.

Вы можете использовать _fallback_ скрытый слот по умолчанию `'head()'` или `'foot()'` для форматирования любых ячеек заголовка или футера, которые не имеют явного скрытого слота.

В `BTableLight`, `'foot(<fieldkey>)'` сначала упадет на `'foot()'`, если он предоставлен, затем на `'head(<fieldkey>)'`, и, наконец, на `'head()'`. Для `BTable` есть дефолт для `'head(<fieldkey>)'`, поэтому цепочка fallback остановится на дефолтном `'head(<fieldkey>)'` вместо того, чтобы упасть на `'head()'`.

<<< DEMO ./demo/TableHeadSlot.vue

Слоты могут быть опционально скопированы (`data` в примере выше), и будут иметь следующие свойства:

| Свойство        | Тип                         | Описание                                                                                        |
| --------------- | --------------------------- | ----------------------------------------------------------------------------------------------- |
| `column`        | `LiteralUnion<keyof Items>` | Ключевое значение поля                                                                          |
| `field`         | `TableField<Items>`         | объект (из пропса `fields`)                                                                     |
| `label`         | `string \| undefined`       | Значение метки поля (также доступно как `data.field.label`)                                     |
| `isFoot`        | `boolean`                   | Текущий рендеринг футера, если `true`                                                           |
| `selectAllRows` | `() => void`                | Выберите все строки (применимо, если таблица в режиме [`selectable`](#row-select-support)       |
| `clearSelected` | `() => void`                | Отмените выбор всех строк (применимо, если таблица в режиме [`selectable`](#row-select-support) |

При размещении элементов ввода, кнопок, выборов или ссылок в скрытом слоте `head(...)` или `foot(...)`, обратите внимание, что событие `head-clicked` не будет вызываться, когда на элементы ввода, выбора, текстового поля или кнопки в скрытых слотах (даже когда они отключены). Событие `head-clicked` никогда не будет вызываться при щелчке по ссылкам или кнопкам внутри скрытых слотов (даже когда они отключены)

**Примечания:**

- Имена слотов **не могут** содержать пробелы, и когда используются в браузерных шаблонах DOM, имена слотов будут _всегда_ в нижнем регистре. Чтобы обойти это, вы можете передать имя слота, используя динамические имена слотов Vue

### Добавление дополнительных строк в заголовок

Если вы хотите добавить дополнительные строки в заголовок, вы можете сделать это через слот `thead-top`. Этот слот вставляется перед строкой ячеек заголовка, и не заключен в теги `<tr>..</tr>`. Рекомендуется использовать компоненты вспомогательной таблицы BootstrapVue, а не встроенные элементы таблицы браузера.

<<< DEMO ./demo/TableHeaderRows.vue

Слот `thead-top` может быть опционально скопирован, получая объект со следующими свойствами:

| Свойство        | Тип                   | Описание                                                                                        |
| --------------- | --------------------- | ----------------------------------------------------------------------------------------------- |
| `columns`       | `number`              | Количество столбцов, отрендеренных в таблице                                                    |
| `fields`        | `TableField<Items>[]` | Массив объектов определения поля (нормализованный в формат массива объектов)                    |
| `selectAllRows` | `() => void`          | Выберите все строки (применимо, если таблица в режиме [`selectable`](#row-select-support)       |
| `clearSelected` | `() => void`          | Отмените выбор всех строк (применимо, если таблица в режиме [`selectable`](#row-select-support) |

### Создание пользовательского футера

Если вам нужен больший контроль над содержимым `<tfoot>`, вы можете использовать опционально скопированный слот `custom-foot` для предоставления своих строк и ячеек. Используйте компоненты вспомогательной подкомпоненты BootstrapVue `<BTr>`, `<BTh>`, и `<BTd>` для генерации вашего пользовательского макета футера.

Слот `custom-foot` может быть опционально скопирован, получая объект со следующими свойствами:

| Свойство  | Тип                   | Описание                                                                                   |
| --------- | --------------------- | ------------------------------------------------------------------------------------------ |
| `columns` | `number`              | Количество столбцов, отрендеренных в таблице                                               |
| `fields`  | `TableField<Items>[]` | Массив объектов определения поля (нормализованный в формат массива объектов)               |
| `items`   | `readonly Items[]`    | Массив текущих _отображаемых_ записей элементов - после фильтрации, сортировки и пагинации |

**Примечания:**

- Слот `custom-foot` не будет отрендерен, если пропс `foot-clone` установлен.
- События `head-clicked` не будут вызываться при щелчке по ячейкам `custom-foot`.
- Сортировка и значки сортировки недоступны для ячеек в слоте `custom-foot`.
- Пользовательский футер не будет показан, когда таблица находится в визуально наложенном режиме.

## Пользовательское отображение пустых и пустых после фильтрации

Содержимое, которое будет отображаться, когда таблица пуста, можно указать, установив пропс `show-empty` и затем указав:

- Либо пропс `empty-text`, либо именованный слот `empty`, для случая, когда необработанные элементы пусты или ложны
- Либо пропс `empty-filtered-text`, либо именованный слот `empty-filtered`, для случая, когда отфильтрованные элементы пусты или ложны

Для того чтобы эти пропсы или слоты отображались, атрибут `show-empty` должен быть установлен, и `items` должен быть
либо ложным, либо массивом длиной 0.

<<< FRAGMENT ./demo/TableEmpty.vue#template{vue-html}

Слот может быть опционально скопирован. Свойства области действия слота (`scope` в примере выше) будут иметь следующие свойства:

| Свойство            | Тип                   | Описание                                                   |
| ------------------- | --------------------- | ---------------------------------------------------------- |
| `emptyFilteredHtml` | `string`              | Пропс `empty-filtered-html`                                |
| `emptyFilteredText` | `string`              | Пропс `empty-filtered-text`                                |
| `fields`            | `TableField<Items>[]` | Пропс `fields`                                             |
| `items`             | `Items[]`             | Пропс `items`. Экспонируется здесь для проверки null vs [] |

::: info ПРИМЕЧАНИЕ
Если вы ранее использовали скрытые слоты `emptyHtml` или `emtpyFilteredHtml` или пропсы `empty-html` или
`empty-filtered-html`, пожалуйста, конвертируйте на использование слотов `empty-text` или `empty-filtered-text` вместо. См. наш [руководство по миграции](/docs/migration-guide#v-html) для деталей.
:::

## Расширенные функции

### Фиксированные заголовки

Используйте пропс `sticky-header`, чтобы включить вертикально прокручиваемую таблицу с фиксированными заголовками, которые остаются фиксированными при прокрутке тела таблицы. Установите пропс в `true` (или без явного значения), чтобы сгенерировать таблицу, которая имеет максимальную высоту `300px`. Чтобы указать другую максимальную высоту, установите пропс `sticky-header` в допустимую высоту CSS (включая единицы), например `sticky-header="200px"`. Таблицы с включенным `sticky-header` автоматически станут всегда отзывчивыми по горизонтали, независимо от настройки пропса `responsive`, если таблица шире, чем доступное горизонтальное пространство.

<<< DEMO ./demo/TableStickyHeaders.vue

**Примечания по фиксированным заголовкам:**

- Пропс `sticky-header` не имеет эффекта, если таблица имеет пропс `stacked` установлен.
- Таблицы с фиксированными заголовками обернуты внутрь вертикально прокручиваемого `<div>` с установленной максимальной высотой.
- BootstrapVue требует пользовательского CSS для поддержки фиксированных заголовков.
- Bootstrap v5 использует стиль CSS `border-collapse: collapsed` на элементах таблицы. Это предотвращает границы на фиксированных заголовках от "прилипания" к заголовку, и поэтому границы будут прокручиваться, когда тело прокручивается. Чтобы обойти эту проблему, установите пропс `no-border-collapse` на таблицу (обратите внимание, что это может вызвать двойные ширины границ при использовании функций, таких как `bordered`, и т.д.).

### Фиксированные столбцы

Столбцы можно сделать фиксированными, где они прилипают к левому краю таблицы при горизонтальной прокрутке. Чтобы сделать столбец фиксированным, установите свойство `stickyColumn` в определении заголовка [поля](#field-definition-reference). Фиксированные столбцы будут работать только тогда, когда таблица имеет установленный пропс `sticky-header` и/или пропс `responsive` установлен в `true`.

<<< DEMO ./demo/TableStickyColumns.vue

**Примечания по фиксированным столбцам:**

- Фиксированные столбцы не имеют эффекта, если таблица имеет пропс `stacked` установлен.
- Таблицы с фиксированными столбцами требуют либо режима `sticky-header`, либо `responsive`, и обернуты внутрь горизонтально прокручиваемого `<div>`.
- Когда у вас есть несколько столбцов, установленных как `stickyColumn`, столбцы будут накладываться друг на друга визуально, и левые фиксированные столбцы могут "выглядывать" под следующим фиксированным столбцом. Чтобы обойти это поведение, убедитесь, что ваши последующие фиксированные столбцы имеют ту же ширину или ширину, большую, чем предыдущие фиксированные столбцы.
- Bootstrap v5 использует стиль CSS `border-collapse: collapsed` на элементах таблицы. Это предотвращает любые границы на фиксированных столбцах от "прилипания" к столбцу, и поэтому эти границы будут прокручиваться, когда тело прокручивается. Чтобы обойти эту проблему, установите пропс `no-border-collapse` на таблицу (обратите внимание, что это может вызвать двойные ширины границ при использовании функций, таких как `bordered`, и т.д.).
- BootstrapVue требует пользовательского CSS для поддержки фиксированных столбцов.
- Функция фиксированного столбца использует стиль CSS `position: sticky` для позиционирования ячеек столбца. Internet Explorer не поддерживает `position: sticky`, поэтому для IE 11 фиксированный столбец будет прокручиваться вместе с телом таблицы.

### Поддержка деталей строк

Если вы хотите опционально отображать дополнительную информацию о записи (например, столбцы, не указанные в массиве определений полей), вы можете использовать скрытый слот `row-details`, в сочетании со специальным свойством `boolean` записи `_showDetails`.

Если запись имеет свойство `_showDetails` установленным в `true`, **и** существует скрытый слот `row-details`, будет показана новая строка, которая будет ниже элемента, с содержимым скрытого слота `row-details`.

В скрытом слоте поля вы можете переключить видимость скрытого слота `row-details` строки, вызывая функцию `toggleDetails`, переданную в скрытый слот переменной поля. Вы можете использовать скрытый слот переменной поля `detailsShowing`, чтобы определить видимость скрытого слота `row-details`.

::: info ПРИМЕЧАНИЕ
Если изменять свойство `_showDetails` напрямую в данных элемента (т.е. не через функцию обратного вызова `toggleDetails`), свойство `_showDetails` **должно** существовать в данных элемента для корректного обнаружения изменений его значения. См. больше о
[как работает реактивность в Vue](https://vuejs.org/guide/extras/reactivity-in-depth.html#Change-Detection-Caveats).
:::

**Доступные свойства области действия `row-details`:**

| Свойство        | Тип                        | Описание                                                                                                                                |
| --------------- | -------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- |
| `item`          | `Items`                    | Полный объект записи строки                                                                                                             |
| `index`         | `number`                   | Текущий видимый номер строки                                                                                                            |
| `fields`        | `TableField<Items>[]`      | Нормализованный массив определений полей (в формате _массива объектов_)                                                                 |
| `toggleDetails` | `() => void`               | Функция для переключения видимости слота деталей строки                                                                                 |
| `rowSelected`   | `boolean`                  | Будет `true`, если строка выбрана. См. раздел [Поддержка выбора строк](#row-select-support) для дополнительной информации               |
| `selectRow`     | `(index?: number) => void` | Когда вызывается, выбирает текущую строку. См. раздел [Поддержка выбора строк](#row-select-support) для дополнительной информации       |
| `unselectRow`   | `(index?: number) => void` | Когда вызывается, отменяет выбор текущей строки. См. раздел [Поддержка выбора строк](#row-select-support) для дополнительной информации |

::: info ПРИМЕЧАНИЕ
свойства области действия, связанные с выбором строк, доступны только в `<BTable>`.
:::

В следующем примере мы показываем два способа переключения видимости деталей: один через кнопку, другой через чекбокс. Мы также показываем, что третья строка деталей по умолчанию имеет видимые детали.

<<< DEMO ./demo/TableRowDetails.vue

### Поддержка выбора строк

Вы можете сделать строки выбираемыми, используя пропс `<BTable>` `selectable`.

Пользователи могут легко изменять режим выбора, устанавливая пропс `select-mode`.

- `'multi'`: Каждый щелчок выбирает/отменяет выбор строки (режим по умолчанию)
- `'single'`: Можно выбрать только одну строку одновременно
- `'range'`: Любой щелчок выбирает строку, любой другой отменяет выбор. <kbd>Shift</kbd> + щелчок выбирает диапазон строк, и <kbd>Ctrl</kbd> (или <kbd>Cmd</kbd>) + щелчок переключает выбранную строку.

Когда таблица `selectable` и пользователь щелкает по строке, `<BTable>` вызывает событие `update:selected-items`, передавая один аргумент, который является полным списком выбранных элементов. **Этот аргумент является доступным только для чтения.** Кроме того, вызываются события `row-selected` или `row-unselected` для каждой строки.

Строки также можно выбирать и отменять выбор программно через следующие экспонированные методы на экземпляре `<BTable>`:

| Метод                          | Описание                                                                                                    |
| ------------------------------ | ----------------------------------------------------------------------------------------------------------- |
| `selectRow(index: number)`     | Выбирает строку с заданным номером `index`.                                                                 |
| `unselectRow(index: number)`   | Отменяет выбор строки с заданным номером `index`.                                                           |
| `selectAllRows()`              | Выбирает все строки в таблице, за исключением случая, когда в режиме `single` выбрана только первая строка. |
| `clearSelected()`              | Отменяет выбор всех строк.                                                                                  |
| `isRowSelected(index: number)` | Возвращает `true`, если строка с заданным номером `index` выбрана, в противном случае — `false`.            |

**Примечания к программному выбору строк:**

- `index` — это нулевой индекс видимых строк таблицы, после применения фильтрации, сортировки и пагинации.
- В режиме `single` вызов `selectRow(index)` отменит выбор любой предыдущей выбранной строки.
- Попытка вызова `selectRow(index)` или `unselectRow(index)` для несуществующей строки будет проигнорирована.
- Таблица должна быть `selectable` для того, чтобы эти методы имели эффект.
- Вы можете отключить выбор строк по щелчкам событий, установив пропс `no-select-on-click` в `true`. Строки будут тогда выбираемыми только программно.

**Примечания по выбору строк:**

- [Сортировка](#sorting), [фильтрация](#filtering), или [пагинация](#pagination) таблицы **очищают активный выбор**. Событие `update:selected-items` будет вызываться с пустым массивом (`[]`) при необходимости.
- Когда таблица находится в режиме `selectable`, все элементы `<tr>` данных таблицы будут находиться в последовательности документа вкладок (`tabindex="0"`) для причин доступности (#accessibility), и будут иметь атрибут `aria-selected` установленным в `'true'` или `'false'` в зависимости от состояния выбранной строки.
- <NotYetImplemented/>Когда таблица находится в режиме `selectable`, таблица будет иметь атрибут `aria-multiselect` установленным в `'false'` для режима `single`, и `'true'` для режимов `multi` или `range`.

<NotYetImplemented/>

Используйте пропс `selected-variant`, чтобы применить цветовой вариант Bootstrap к выбранной строке(ам). Обратите внимание, из-за порядка, в котором определяются варианты таблицы в CSS Bootstrap, любая строковая вариация _может_ иметь приоритет над `selected-variant`. Вы можете установить `selected-variant` в пустую строку, если вы будете использовать другие средства для передачи того, что строка выбрана (например, скрытый слот поля в примере ниже).

`selected-variant` может быть любой из
[стандартных (или пользовательских) базовых цветовых вариантов Bootstrap](/docs/reference/color-variants), или специальный
[вариант таблицы `active` (по умолчанию)](/docs/reference/color-variants#table-variants), который имеет приоритет над любым конкретным рядом или ячейкой вариантов.

Для доступности (особенно для пользователей с цветовой слепотой или с проблемами контраста) рекомендуется всегда предоставлять какое-либо другое визуальное средство для передачи того, что строка выбрана, как показано в примере ниже.

<<< DEMO ./demo/TableRowSelect.vue

### Поддержка перехода тела таблицы

<NotYetImplemented />

### Экспонированные функции

См. раздел [Поддержка выбора строк](#row-select-support) для экспонированных функций, связанных с выбором.

| Метод                                            | Описание                                                                                                                                                          |
| ------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `items(): Items[]`                               | Возвращает полный набор элементов, использованных для построения таблицы.                                                                                         |
| `displayItems(): Items[]`                        | Возвращает набор элементов, отображаемых в таблице. См. пример [Полный пример](#complete-example) для использования                                               |
| `getStringValue(ob: Items, key: string): string` | Возвращает отформатированное строковое значение поля `key` объекта `ob`. См. использование [Сравниватели пользовательской сортировки(s)](#custom-sort-comparer-s) |
| `refresh()`                                      | Вызывает асинхронного поставщика для обновления элементов таблицы                                                                                                 |

## Сортировка

Как упоминалось в разделе [Поля](#fields-column-definitions) выше, вы можете сделать столбцы сортируемыми в `<BTable>`. Щелчок по заголовку сортируемого столбца приведет к сортировке столбца в направлении восходящего порядка (наименьшее первое), в то время как повторный щелчок приведет к переключению направления сортировки в нисходящем порядке (наибольшее первое). Третий щелчок остановит сортировку на столбце. Для односторонней сортировки (например, `multisort===false`) щелчок по заголовку другого сортируемого столбца сортирует этот столбец в восходящем порядке, а сортировка предыдущего отсортированного столбца очищается.

Вы можете контролировать, какой столбец предварительно отсортирован и порядок сортировки (восходящий или нисходящий). Чтобы предварительно указать столбец для сортировки, используйте модель `sortBy`. Для односторонней сортировки (например, `multisort===false`) `sortBy` должен быть массивом, содержащим один объект `BTableSortBy` с определенным полем `order`.

<<< FRAGMENT ./demo/TableSortBy.ts#snippet{ts}

- **Восходящий**: Элементы сортируются с наименьшего к наибольшему (например, `A` к `Z`), и будут отображаться с наименьшим значением в первой строке с прогрессивно возрастающими значениями в последующих строках.
- **Нисходящий**: Элементы сортируются с наибольшего к наименьшему (например, `Z` к `A`), и будут отображаться с наибольшим значением в первой строке с прогрессивно убывающими значениями в последующих строках.

По умолчанию функция сравнения выполняет `numeric localeCompare`. Если вы хотите изменить это, используйте пользовательскую функцию сравнения с этим элементом `BTableSortBy`.

Чтобы предотвратить таблицу отстирания функции сравнения, внутренне она установит ключ `order` в `undefined`, а не просто удалит элемент из массива `sortBy`. Т.е. `:sort-by="[]"` & `:sort-by="[key: 'someKey', order: undefined]"` ведут себя одинаково. Естественно, если это значение передается на сервер, порядки `undefined` должны быть обработаны. См. вычисленную функцию `singleSortBy` ниже как простое средство получения ссылки на отсортированный столбец из таблицы, которая находится в одностороннем режиме сортировки.

<<< DEMO ./demo/TableSort.vue

`sorbBy` — это [именованная модель](https://vuejs.org/guide/components/v-model.html#multiple-v-model-bindings), поэтому она может быть связана с объектом, который будет обновляться с текущим состоянием сортировки при изменении сортировки щелчком по заголовкам.

<<< DEMO ./demo/TableSortBy.vue

Таблицы можно сортировать по нескольким столбцам программно, добавив больше записей в массив `sortBy`. От пользовательского интерфейса, многосортировка работает следующим образом:

- Щелчок по сортируемому заголовку, который не отсортирован, добавляет его как `ascending` в конец списка `sortBy`
- Щелчок по сортируемому заголовку, который уже отсортирован по восходящему, делает его **нисходящим**, но оставляет его в том же порядке в списке `sortBy`
- Щелчок по сортируемому заголовку, который уже отсортирован по нисходящему, устанавливает порядок на `undefined`. Если `must-sort` установлен в `true` ИЛИ если `mustSort` является массивом, который содержит ключ столбца, он пропустит и установит порядок на `ascending`

<<< DEMO ./demo/TableSortByMulti.vue

### Сравниватели пользовательской сортировки(s)

Каждый элемент в модели `BSortBy` может включать поле `comparer` типа `BTableSortByComparerFunction<T = any> = (a: T, b: T, key: string) => number`. Эта функция принимает элементы для сравнения и ключ для сравнения. Поскольку ключ передается, вы можете использовать одну и ту же функцию для нескольких полей или вы можете создать разные функции сравнения для каждого поля. Если поле `comparer` не определено (или не определено поле в массиве `sortBy` вообще), оно упадет на использование дефолтного сравнения, которое выглядит так:

<<< FRAGMENT ./demo/TableSortCompareDefault.ts#snippet{ts}

где `getStringValue` извлекает значение поля как строку.

Если у вас есть определенное поле, которое вы хотите отсортировать, вы можете установить запись модели `sortBy` с пользовательским сравнением:

<<< FRAGMENT ./demo/TableSortCompareCustom.ts#snippet{ts}

Алгоритм сортировки по умолчанию анализирует синтаксис объекта, используя внутреннюю функцию `getStringValue`. Его основное назначение — извлекать правильное значение из различных типов (объект, строка и т.д.), например `{foo: {bar: '1'}}`, можно использовать `'foo.bar'` в качестве входных данных для функции, чтобы получить значение в объекте -- `1`. Он также возвращает результат после форматирования. Эта функция доступна для настройки.
с разными опциями.

В примере ниже мы включаем сортировку, включая регистр, но можно было бы так же установить локализацию или модифицировать
любую из других опций [`localeCompare`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)

<<< DEMO ./demo/TableSortByCustom.vue

## Фильтрация

Когда используется, фильтрация применяется по умолчанию к **исходным данным** массива элементов. `Btable` предоставляет несколько опций для того, как данные фильтруются.

В настоящее время невозможно фильтровать на основе результата форматирования через
[скрытые слоты поля](#scoped-field-slots).

### Встроенная фильтрация

Значения строк данных записи строковые (см. раздел сортировки выше, как выполняется строковый формат) и фильтр ищет эти строковые данные (исключая любые специальные свойства, начинающиеся с подчеркивания `'_'`). Строковый форматирование также, по умолчанию, включает любые данные, которые не отображаются в представленных столбцах.

С функцией встроенного фильтра по умолчанию пропс `filter` может быть либо строкой, либо объектом `RegExp` (регулярные выражения не должны иметь флаг `/g` глобального поиска). <NotYetImplemented/> В настоящее время пропс `filter` поддерживает только строку, а не `RegExp`.

Если строковая строка записи содержит предоставленное строковое значение или соответствует выражению `RegExp`, то она включается в отображаемые результаты.

Установите пропс `filter` в `null` или пустую строку, чтобы очистить текущий фильтр.

### Встроенные опции фильтрации

Существует несколько опций для контроля того, на какие данные применяется фильтр.

- <NotYetImplemented/>Пропс `filter-ignored-fields` принимает массив ключей _верхнего уровня_ (непосредственных свойств данных строки) полей, которые следует игнорировать при фильтрации.
- <NotYetImplemented/>Пропс `filter-included-fields` принимает массив ключей _верхнего уровня_ (непосредственных свойств данных строки) полей, которые следует использовать при фильтрации. Все другие ключи полей, не включенные в этот массив, будут игнорироваться. Эта функция может быть полезна, когда вы хотите фильтровать по определенным столбцам. Если указанный массив пуст, то _все_ поля включаются, за исключением тех, которые указаны через пропс `filter-ignored-fields`. Если ключ поля указан в обоих `filter-ignored-fields` и `filter-included-fields`, то `filter-included-fields` имеет приоритет.
- Обычно, `<BTable>` фильтрует на основе строковых данных записи. Если поле имеет указанную функцию форматирования, вы можете опционально фильтровать на основе результата форматирования, установив свойство [определения поля](#field-definition-reference) `filterByFormatted` в `true`. Если поле не имеет функции форматирования, эта опция игнорируется. <NotYetImplemented/>Вы можете опционально передать функцию форматирования _ссылку_, которая будет использоваться для фильтрации только, в свойство `filterByFormatted`.

Пропсы `filter-ignored-fields` и `filter-included-fields`, а также свойство `filterByFormatted` определения поля не имеют эффекта при использовании [пользовательской функции фильтрации](#custom-filter-function) или фильтрации на основе [функций поставщика элементов](#using-items-provider-functions).

### Пользовательская функция фильтрации

Вы также можете использовать пользовательскую функцию фильтрации, установив пропс `filter-function` в ссылку на пользовательскую функцию теста фильтра. Сигнатура функции фильтрации: `(item: Readonly<Items>, filter: string | undefined) => boolean`

- `item` — это исходный объект записи строки.
- `filter` — значение пропса `filter`

Функция должна возвращать `true`, если запись соответствует вашим критериям, или `false`, если запись должна быть отфильтрована.

Для корректного обновления отображаемых данных, когда фильтрация не применяется, вы должны установить пропс `filter` в `null` или пустую строку (и не в пустой объект или массив). Функция фильтрации не будет вызываться, когда пропс `filter` является ложным значением.

Отображение `empty-filter-text` зависит от истинности пропса `filter`.

### События фильтрации

Когда локальная фильтрация применяется, и количество отображаемых элементов изменяется, `<BTable>` вызывает событие `filtered` с одним аргументом типа `Items[]`: который является полным списком элементов, прошедших процедуру фильтрации. **Рассматривайте этот аргумент как доступный только для чтения.**

Установка пропса `filter` в `null` или пустую строку очищает локальную фильтрацию элементов.

## Пагинация

`<BTable>` поддерживает встроенную пагинацию данных элементов. Вы можете контролировать, сколько строк отображается за раз, установив пропс `per-page` в максимальное количество строк, которое вы хотели бы отображать, и
используя пропс `current-page` для указания, какую страницу отображать (начиная с страницы `1`). Если вы установите `current-page` в значение, превышающее вычисленное количество страниц, то строки не будут отображаться.

Вы можете использовать компонент [`<BPagination>`](/docs/components/pagination) в сочетании с `<BTable>`, чтобы предоставить контроль над пагинацией.

## Использование функций поставщика элементов

Как упоминалось в разделе [Элементы](#items-record-data) пропса, возможно использование функции для
предоставления данных строк (элементов) путем указания ссылки на функцию через пропс `provider` и оставляя пропс `items` неопределенным.

::: info ПРИМЕЧАНИЕ
Если одновременно установлены пропсы `provider` и `items`, пропс `provider` будет использоваться, и `items` будет проигнорирован.
:::

Функция поставщика вызывается с следующей сигнатурой:

<<< FRAGMENT ./demo/TableProvider.ts#snippet{ts}

`ctx` — это объект контекста, связанный с состоянием таблицы, который содержит следующие свойства:

| Свойство      | Тип                              | Описание                                                                                         |
| ------------- | -------------------------------- | ------------------------------------------------------------------------------------------------ |
| `currentPage` | `number`                         | Номер текущей страницы (начиная с 1, значение пропса `current-page`)                             |
| `perPage`     | `number`                         | Максимальное количество строк для отображения на страницу (значение пропса `per-page`)           |
| `filter`      | `string \| undefined`            | Значение пропса `filter`                                                                         |
| `sortBy`      | `BTableSortBy<T>[] \| undefined` | Текущий ключ столбца, по которому сортируется, или пустая строка, если сортировка не выполняется |

Ниже приведены урезанные версии [полного примера](#complete-example) как отправная точка для использования функций поставщика. Они используют локальные функции поставщика, которые реализуют сортировку и фильтрацию. Обратите внимание, что сортировка выполняется в сотрудничестве с `<BTable>`, когда функция поставщика реагирует на массив `context.sortBy`, который ей передается, в то время как фильтрация выполняется полностью поставщиком, который вручную заставляет таблицу обновиться при изменении фильтра.

Пример использования синхронной функции поставщика:

<<< DEMO ./demo/TableProvider.vue

Пример использования асинхронной функции поставщика, которая имитирует задержку, засыпая на секунду:

<<< DEMO ./demo/TableProviderAsync.vue

## Легковесные таблицы

`<BTableLite>` предоставляет отличную альтернативу `<BTable>`, если вам нужно простое отображение
табличных данных. Компонент `<BTableLite>` предоставляет все функции стилизации и форматирования `<BTable>` (включая детали строк и поддержку наложения), в то время как **исключая** следующие функции:

- Фильтрация
- Сортировка
- Пагинация
- Поддержка поставщика элементов
- Выбираемые строки
- Состояние занятости таблицы и стилизация
- Фиксированные верхнюю и нижнюю строки
- Поддержка пустой строки

## Простые таблицы

Компонент `BTableSimple` дает полный контроль над рендерингом содержимого таблицы, в то время как предоставляя базовую стилизацию таблицы Bootstrap v5. `BTableSimple` — это обертка компонента `<table>`, внутри которого вы можете использовать любой или все компоненты вспомогательной таблицы BootstrapVueNext: `BThead`, `BTfoot`, `BTbody`, `BTr`, `BTh`, `BTd`, и HTML5 элементы `<caption>`, `<colgroup>` и `<col>`. В отличие от названия компонента, можно создавать простые или сложные макеты таблиц с `BTableSimple`.

`BTableSimple` предоставляет базовые стилевые опции через пропсы: striped, bordered, borderless, outlined, small, hover, dark, fixed, responsive и sticky-header. Обратите внимание, что режим наложения доступен, но требует небольшой дополнительный код для генерации заголовков ячеек, как описано в разделах "Простые таблицы" и "Режим наложения" ниже. Фиксированные столбцы также поддерживаются, но также требуют немного дополнительного кода для указания, какие столбцы должны быть фиксированными. См. ниже для получения дополнительной информации о поддержке фиксированных столбцов.

Поскольку `BTableSimple` — это просто обертка компонента, внутри которого вам нужно рендерить содержимое, он не предоставляет никаких расширенных функций `BTable` (например, события строк, события заголовка, сортировка, пагинация, фильтрация, foot-clone, items, fields и т.д.).

<<< DEMO ./demo/TableSimpleOverview.vue#template{vue-html}

Когда в режиме отзывчивости или sticky-header, элемент `<table>` обернут внутрь элемента `<div>`. Если вам нужно применить дополнительные классы или атрибуты к элементу `<table>`, используйте пропсы `table-classes` и `table-attrs`, соответственно.

### Простые таблицы и режим наложения

Небольшой дополнительный код требуется в ячейках тела таблицы вашего `BTableSimple`, когда таблица находится в режиме наложения. В частности, BootstrapVueNext использует специальный атрибут данных для создания заголовка ячейки, который вы можете предоставить `BTd` или `BTh` через пропс `stacked-heading`. Поддерживаются только простые строки (не HTML-разметка), так как мы используем псевдоэлемент `::before` и свойство `content` CSS.

Вот та же таблица, установленная на всегда наложенный режим, который имеет дополнительный код для обработки режима наложения (конкретно для генерации заголовков ячеек):

<<< DEMO ./demo/TableSimpleStacked.vue#template{vue-html}

Как `BTable` и `BTableLite`, заголовки таблицы (`<thead>`) и футеры (`<tfoot>`) визуально скрываются, когда таблица визуально наложена. Если вам нужен заголовок или футер, вы можете сделать это, создав дополнительный `BTr` внутри компонента `BTbody` (или во втором компоненте `BTbody`), и установив роль `columnheader` на дочерние ячейки `BTh`, и использовать утилиты отображения отзывчивости Bootstrap v5 для скрытия дополнительной строки (или `BTbody`) выше определенной точки останова, когда таблица больше не визуально наложена (точка останова должна соответствовать точке останова наложенной таблицы, которую вы установили), т.е. `<BTr class="d-md-none">` скроет строку на экранах среднего и более широкого размера, а `<BTbody class="d-md-none">` скроет группу строк на экранах среднего и более широкого размера.

::: info ПРИМЕЧАНИЕ
Обратите внимание: режим наложения с `BTableSimple` требует использования компонентов вспомогательной таблицы BootstrapVueNext.
Использование обычных элементов таблицы браузера (например, `<tbody>`, `<tr>`, `<td>`, и т.д.) внутри `<BTableSimple>`, а также именованных слотов `top-row`, `bottom-row`, и `thead-top` не будет работать так, как ожидается, ни они не будут автоматически применять какие-либо атрибуты доступности.
:::

### Простые таблицы и фиксированные столбцы

Фиксированные столбцы поддерживаются с `BTableSimple`, но вам нужно будет установить пропс `sticky-column` на каждую ячейку таблицы (в `thead`, `tbody`, и `tfoot` группах строк) в столбце, который должен быть фиксированным. Например:

<<< FRAGMENT ./demo/TableSimpleSticky.vue#template{vue-html}

Как и `BTable` и `BTableLite`, фиксированные столбцы не поддерживаются, когда пропс `stacked` установлен на `BTableSimple`.

## Компоненты вспомогательной таблицы

BootstrapVueNext предоставляет дополнительные вспомогательные дочерние компоненты при использовании `<BTableSimple>`, или именованных слотов `top-row`, `bottom-row`, `thead-top`, и `custom-foot` (все из которых принимают элементы таблицы в качестве дочерних). Вспомогательные компоненты следующие:

- `BTbody` (`<BTableSimple>` только)
- `BThead` (`<BTableSimple>` только)
- `BTfoot` (`<BTableSimple>` только)
- `BTr`
- `BTd`
- `BTh`

Эти компоненты оптимизированы для преобразования вариантов в соответствующие классы (например, обработка режима `dark` таблицы, поддержка цветовой темы), и автоматического применения определенных атрибутов доступности (например, `role`s и `scope`s). Они также могут генерировать наложенную таблицу, фиксированные заголовки и столбцы, разметку. Компоненты `<BTable>` и `<BTableLite>` используют эти вспомогательные компоненты внутренне.

В примере [Простые таблицы](#simple-tables) мы используем вспомогательные компоненты `<BThead>`,
`<BTbody>`, `<BTr>`, `<BTh>`, `<BTd>` и `<BTfoot>`. Хотя вы можете использовать обычные элементы таблицы браузера (например, `<tbody>`, `<tr>`, `<td>`, и т.д.) внутри `<BTableSimple>`, а также именованные слоты `top-row`, `bottom-row`, и `thead-top`, рекомендуется использовать эти компоненты BootstrapVue `<BT*>` вспомогательные компоненты. Обратите внимание, что нет вспомогательных компонентов для `<caption>`, `<colgroup>` или `<col>`, поэтому вы можете использовать эти три HTML5 элемента непосредственно в `<BTableSimple>`.

- Вспомогательные компоненты `<BThead>`, `<BTfoot>`, `<BTr>`, `<BTd>` и `<BTh>` все принимают пропс `variant`, который применяет один из цветов Bootstrap (поддерживаются пользовательские цвета темы через [темизацию](/docs/reference/theming).) и автоматически корректируется для использования правильного класса варианта на основе режима `dark` таблицы.
- <NotYetImplemented/> Атрибуты доступности `role` и `scope` автоматически устанавливаются на компоненты `<BTh>` и `<BTd>`, основанные на их расположении (thead, tbody, или tfoot) и их пропсах `rowspan` или `colspan`. Вы можете переопределить автоматические значения `scope` и `role` с помощью атрибута на компоненте вспомогательного компонента.
- <NotYetImplemented/> Для компонентов вспомогательных компонентов `<BTbody>`, `<BThead>` и `<BTfoot>`, соответствующий дефолтный `role` `'rowgroup'` будет применен, если вы не переопределите роль с помощью атрибута `role`.
- <NotYetImplemented/> Для компонента `<BTr>`, соответствующий дефолтный `role` `'row'` будет применен, если вы не переопределите роль с помощью атрибута `role`. `<BTr>` не добавляет `scope`.
- <NotYetImplemented/> Элемент `<BTbody>` поддерживает рендеринг Vue `<transition-group>`, когда либо, либо оба, пропсы `tbody-transition-props` и `tbody-transition-handlers` используются. См. раздел [Поддержка перехода тела таблицы](#table-body-transition-support) для получения дополнительной информации.

## Доступность

<NotYetImplemented/>

Компоненты `<BTable>` и `<BTableLite>`, когда используются определенные функции, пытаются предоставить наилучшую разметку доступности.

Когда используется `<BTableSimple>` с вспомогательными компонентами таблицы, элементы будут иметь соответствующие роли, которые по умолчанию можно опционально переопределить. Когда вы используете обработчики щелчков на компонентах `<BTableSimple>` вспомогательных компонентов, вам нужно будет применять соответствующие атрибуты `aria-*`, и установить `tabindex="0"` для доступности щелчков на ячейках или строках (требуется для доступности для пользователей клавиатуры). Вы также должны слушать `@keydown.enter.prevent`, чтобы обрабатывать нажатие <kbd>Enter</kbd> пользователями для активации щелчков на ячейках или строках (требуется для доступности для пользователей клавиатуры).

### Доступность заголовка

<NotYetImplemented/>

Когда столбец (поле) сортируемый (`<BTable>` только) или зарегистрирован обработчик события `head-clicked` (`<BTable>` и `<BTableLite>`), ячейки заголовка (`<th>`) будут помещены в последовательность документа вкладок (через `tabindex="0"`) для доступности для пользователей клавиатуры и экранов.

### Ряд доступности данных

<NotYetImplemented/>

Когда таблица находится в режиме `selectable` (`<BTable>` только, и пропс `no-select-on-click` не установлен), или если зарегистрирован обработчик события `row-clicked` (`<BTable>` и `<BTableLite>`), все элементы строк данных (`<tr>` элементы) будут помещены в последовательность документа вкладок (через `tabindex="0"`) для доступности для пользователей клавиатуры и экранов.

Когда элементы строк таблицы (`<BTable>` и
`<BTableLite>`) помещены в последовательность документа вкладок, они также поддерживают базовую навигацию клавиатуры при фокусе:

- <kbd>Down</kbd> переместится на следующую строку
- <kbd>Up</kbd> переместится на предыдущую строку
- <kbd>End</kbd> или <kbd>Down</kbd>+<kbd>Shift</kbd> переместится на последнюю строку
- <kbd>Home</kbd> или <kbd>Up</kbd>+<kbd>Shift</kbd> переместится на первую строку
- <kbd>Enter</kbd> или <kbd>Space</kbd> для щелчка по строке.

### События строки доступности

Обратите внимание на следующие события/действия на основе строк (доступны с `<BTable>` и `<BTableLite>`) не считаются доступными и должны использоваться только в том случае, если функциональность критична или может быть предоставлена другими средствами:

- `row-dblclicked`
- `row-contextmenu`
- `row-hovered`
- `row-unhovered`
- `row-middle-clicked`

Обратите внимание, что событие `row-middle-clicked` не поддерживается во всех браузерах (например, IE, Safari и большинство мобильных браузеров). Когда вы слушаете события `row-middle-clicked`, возникающие на элементах, которые не поддерживают ввод или навигацию, вы часто захотите явно предотвратить другие действия по умолчанию, назначенные на действие вниз средней кнопки мыши. На Windows это обычно автоскролл, а на macOS и Linux — обычно вставка из буфера обмена. Это можно сделать, предотвратив поведение по умолчанию события `mousedown` или `pointerdown`.

Кроме того, вы можете избежать открытия системного или браузерного контекстного меню после правого щелчка. Из-за разницы во времени между операционными системами это также не является предотвращаемым поведением по умолчанию `row-middle-clicked`. Вместо этого это можно сделать, предотвратив поведение по умолчанию события `row-contextmenu`.

Рекомендуется протестировать ваше приложение в качестве возможных вариантов браузера и устройств, чтобы убедиться, что ваше приложение обрабатывает различные несоответствия с событиями.

## Полный пример

<<< DEMO ./demo/TableComplete.vue

<ComponentReference :data="data" />

<script setup lang="ts">
import {data} from '../../data/components/table.data'
</script>
